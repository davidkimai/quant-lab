"""
Signal models for strategy output.

A Signal represents a trading decision generated by a strategy,
including the ticker, action, quantity, and confidence.
"""

from decimal import Decimal
from enum import Enum
from typing import Optional
from pydantic import BaseModel, Field, field_validator


class SignalAction(str, Enum):
    """Trading actions a strategy can recommend."""
    
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    SHORT = "short"
    COVER = "cover"


class Signal(BaseModel):
    """
    Trading signal generated by a strategy.
    
    Attributes:
        ticker: Stock symbol (e.g., 'AAPL', 'MSFT')
        action: Trading action to take
        quantity: Number of shares (0 for HOLD)
        confidence: Signal confidence score [0.0, 1.0]
        reasoning: Optional explanation of the decision
        metadata: Additional strategy-specific data
    """
    
    ticker: str = Field(..., min_length=1, max_length=10)
    action: SignalAction
    quantity: Decimal = Field(default=Decimal("0"), ge=0)
    confidence: float = Field(default=0.5, ge=0.0, le=1.0)
    reasoning: Optional[str] = None
    metadata: dict[str, float | str | int] = Field(default_factory=dict)
    
    @field_validator("ticker")
    @classmethod
    def ticker_uppercase(cls, v: str) -> str:
        """Normalize ticker to uppercase."""
        return v.upper().strip()
    
    @field_validator("quantity", mode="before")
    @classmethod
    def convert_quantity(cls, v: float | int | Decimal) -> Decimal:
        """Ensure quantity is Decimal for precision."""
        return Decimal(str(v)) if not isinstance(v, Decimal) else v
    
    def is_actionable(self) -> bool:
        """Check if signal requires action (not HOLD)."""
        return self.action != SignalAction.HOLD and self.quantity > 0
    
    class Config:
        frozen = True  # Immutable
        use_enum_values = True
